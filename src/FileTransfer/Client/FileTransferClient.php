<?php

namespace Nogrod\eBaySDK\FileTransfer\Client;

use Http\Client\HttpClient;
use Http\Discovery\StreamFactoryDiscovery;
use Http\Message\MessageFactory;
use Http\Message\MultipartStream\MultipartStreamBuilder;
use JMS\Serializer\Serializer;
use Nogrod\eBaySDK\Constants\Version;
use Nogrod\eBaySDK\FileTransfer\UploadFileRequestType;
use Nogrod\eBaySDK\FileTransfer\XopInclude;

class FileTransferClient extends FileTransferBaseClient
{
    public const X_EBAY_SOA_SERVICE_VERSION = 'X-EBAY-SOA-SERVICE-VERSION';

    public const X_EBAY_SOA_SECURITY_TOKEN = 'X-EBAY-SOA-SECURITY-TOKEN';

    public const X_EBAY_SOA_OPERATION_NAME = 'X-EBAY-SOA-OPERATION-NAME';

    public const PRODUCTION_URL = 'https://storage.ebay.com/FileTransferService';

    public const SANDBOX_URL = 'https://storage.sandbox.ebay.com/FileTransferService';

    public function __construct(array $config = [], Serializer $serializer = null, MessageFactory $messageFactory = null, HttpClient $client = null)
    {
        $config = array_merge([
            'sandbox' => false,
            'version' => Version::FILETRANSFER,
            'appId' => null,
        ], $config);
        parent::__construct($config, $serializer, $messageFactory, $client);
    }

    protected function getUrl()
    {
        return $this->getConfig('sandbox') ? self::SANDBOX_URL : self::PRODUCTION_URL;
    }

    protected function buildRequest($operation, $message)
    {
        if ($message instanceof UploadFileRequestType && ($fileAttachment = $message->getFileAttachment()) !== null) {
            $streamFactory = StreamFactoryDiscovery::find();
            $builder = new MultipartStreamBuilder($streamFactory);
            $data = $fileAttachment->getData();
            $xopInclude = new XopInclude();
            $xopInclude->setHref('cid:attachment.bin@nogrod');
            $fileAttachment->setData('[#data#]');
            $xmlMessage = $this->serialize($message);
            $xmlMessage = str_replace('[#data#]', preg_replace('/<\?xml[^>]+\?>/im', '', $this->serialize($xopInclude)), $xmlMessage);
            $builder
                ->addResource('xml', $xmlMessage, ['headers' => [
                    'Content-Type' => 'application/xop+xml;charset=UTF-8;type="text/xml"',
                    'Content-Transfer-Encoding' => '8bit',
                    'Content-ID' => '<request.xml@nogrod>',
                    'Content-Disposition' => null,
                ]])
                ->addResource('file', $data, ['headers' => [
                    'Content-Type' => 'application/octet-stream',
                    'Content-Transfer-Encoding' => 'binary',
                    'Content-ID' => '<attachment.bin@nogrod>',
                    'Content-Disposition' => null,
                ]]);

            $multipartStream = $builder->build();
            $boundary = $builder->getBoundary();

            $request = $this->messageFactory->createRequest('POST', $this->getUrl(), array_merge($this->buildHeaders($operation), [
                'Content-Type' => 'multipart/related;boundary="' . $boundary . '";type="application/xop+xml";start="<request.xml@nogrod>";start-info="text/xml"'
            ]), $multipartStream);
            //echo \GuzzleHttp\Psr7\str($request);

            return $request;
        }

        return parent::buildRequest($operation, $message);
    }

    protected function handleResponse($response, $outClass)
    {
        $responseBody = (string) $response->getBody();
        //echo $responseBody.PHP_EOL;
        if (strpos($responseBody, 'application/xop+xml') !== false) {
            preg_match('/\r\n/', $responseBody, $matches, PREG_OFFSET_CAPTURE);
            $boundary = substr($responseBody, 0, $matches[0][1]);
            $xmlStartPos = strpos($responseBody, '<?xml ');
            $xmlEndPos = strpos($responseBody, $boundary, $xmlStartPos) - 2;
            $xml = substr($responseBody, $xmlStartPos, $xmlEndPos - $xmlStartPos);
            preg_match('/\r\n\r\n/', $responseBody, $matches, PREG_OFFSET_CAPTURE, $xmlEndPos);
            $attachmentStartPos = $matches[0][1] + 4;
            $attachmentEndPos = strpos($responseBody, $boundary, $attachmentStartPos) - 2;
            $attachment = substr($responseBody, $attachmentStartPos, $attachmentEndPos - $attachmentStartPos);
            $result = $this->deserialize($xml, $outClass);
            $result->getFileAttachment()->setData($attachment);
            return $result;
        }

        return parent::handleResponse($response, $outClass); // TODO: Change the autogenerated stub
    }

    protected function buildHeaders(string $operation)
    {
        $headers = [];
        $headers[self::X_EBAY_SOA_SECURITY_TOKEN] = $this->getConfig('auth');
        $headers[self::X_EBAY_SOA_OPERATION_NAME] = $operation;
        $headers[self::X_EBAY_SOA_SERVICE_VERSION] = $this->getConfig('version');

        return $headers;
    }

    protected function handleResponseError($response, $request)
    {
        //echo (string) $response->getBody();
        $error = $this->deserialize((string) $response->getBody(), 'Nogrod\eBaySDK\FileTransfer\ErrorMessageType');
        var_dump($error);
        parent::handleResponseError($response, $request);
    }
}
